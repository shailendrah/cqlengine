 oracle.cep.logging.LogUtil log
CONFIG: Metadata storage : oracle/work/cep/storage
 oracle.cep.logging.LogUtil log
CONFIG: Spill storage : oracle/work/cep/storage/data
 oracle.cep.logging.LogUtil log
CONFIG: ===  QueueSrcPolicy 
 oracle.cep.logging.LogUtil log
CONFIG: normalThreshold ,partialSpillThreshold ,fullSpillThreshold ,syncSpillThreshold 
 oracle.cep.logging.LogUtil log
CONFIG: window = 5
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_S (c1 integer, c2 float) is application timestamped 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_S1 (c1 integer) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_S5 (c1 integer, c2 float) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_SP3(c1 integer, name char(10)) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_S3 (c1 float) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_S12(c1 integer, c2 float) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_SP3 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpSP1.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create stream tklog_S0 (c1 integer, c2 float) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_S0 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpPattern0.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_S5 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpPattern5.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_S3 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/coverage3.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_S12 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpS12.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create relation tklog_R (d1 integer, d2 char(10)) is silent 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create relation tklog_R1 (c1 integer, c2 float) is silent 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_S add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpS1000.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter stream tklog_S1 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpS1_data1.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter relation tklog_R add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpR.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter relation tklog_R1 add source "<EndPointReference><Address>file://pcbpel/cep/test/data/inpR-static.txt</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create view tklog_v1 (c1 integer, c2 float) as select * from tklog_S[range 1] 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create view tklog_v2 (c1 integer) as IStream(select * from tklog_S1[range 10 slide 10]) 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_q1 as select * from tklog_R, tklog_S[range 1] where tklog_S.c1 = tklog_R.d1 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_q2 as tklog_R1 union all tklog_v1 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_q3 as tklog_R1 except tklog_v1 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_q5 as select c1, element_time from tklog_v2 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create function tklog_secondMax(c1 float) return float aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create function tklog_secondMax(c1 char) return char aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create function tklog_secondMax(c1 byte) return byte aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create function tklog_secondMax(c1 timestamp) return timestamp aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create function tklog_secondMax(c1 interval) return interval aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_uda_float_float as select tklog_secondMax(c1) from tklog_S3[range 7] 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create window tklog_range_slide(winrange int, winslide int) implement using "oracle.cep.test.userfunctions.TkRangeSlide" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_q79 as select * from tklog_S12 [tklog_range_slide(10,5)] 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_qp1 as select T.Ac1,T.Bc1,T.Dc1 from tklog_S0 MATCH_RECOGNIZE ( MEASURES A.c1 as Ac1, B.c1 as Bc1, D.c1 as Dc1 PATTERN(A B C* D) DEFINE A as A.c1 = 30, B as B.c2 = 10.0, C as C.c1 = 7, D as D.c1 = 40) as T 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  create query tklog_qp10 as select T.Ac1, T.sumB, T.Cc1 from tklog_S5 MATCH_RECOGNIZE ( MEASURES A.c1 as Ac1, sum(B.c1) as sumB, C.c1 as Cc1 PATTERN(A B* C) DEFINE A as A.c1 = 10, B as B.c1 > A.c1 , C as C.c1 > B.c1) as T 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_qp1 add destination "<EndPointReference><Address>file://oracle/work/cep/patternout1.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_qp10 add destination "<EndPointReference><Address>file://oracle/work/cep/patternout10.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q1 add destination "<EndPointReference><Address>file://oracle/work/cep/outSR1-static.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q2 add destination "<EndPointReference><Address>file://oracle/work/cep/outSR1-union-static.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q3 add destination "<EndPointReference><Address>file://oracle/work/cep/outSR1-except-static.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q5 add destination "<EndPointReference><Address>file://oracle/work/cep/outq5_data1.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_uda_float_float add destination "<EndPointReference><Address>file://oracle/work/cep/outuda6_l.log</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q79 add destination "<EndPointReference><Address>file://oracle/work/cep/outS12great_rs_l.og</Address></EndPointReference>" 
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q1 start 
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpR.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpS1000.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/outSR1-static.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q2 start 
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpR-static.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/outSR1-union-static.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q3 start 
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/outSR1-except-static.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q5 start 
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpS1_data1.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/outq5_data1.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_qp1 start 
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpPattern0.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/patternout1.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_qp10 start 
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpPattern5.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/patternout10.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_uda_float_float start
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/coverage3.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/outuda6_l.log
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter query tklog_q79 start
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://pcbpel/cep/test/data/inpS12.txt
 oracle.cep.logging.LogUtil log
INFO: InterfaceManager: uriStr = file://oracle/work/cep/outS12great_rs_l.og
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter system dump logging systemstate level 8 
 oracle.cep.logging.LogUtil log
FINE: trace : area=SYSTEMSTATE event=DUMP target=SystemState levels=8 
 oracle.cep.logging.LogUtil log
FINE:  <Event Name="DUMP" TargetId="0" TargetName="SystemState">
  <Level Name="SYSTEMSTATE_LOGLEVELS" Value="8">
   <Levels>
   </Levels>
  </Level>
 </Event>

 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL =  alter system run duration = 2 
 oracle.cep.logging.LogUtil log
INFO: Scheduler = oracle.cep.execution.scheduler.FIFOScheduler
 oracle.cep.logging.LogUtil log
INFO: Scheduler State : RUNNING
 oracle.cep.logging.LogUtil log
INFO: Scheduler State : STOPPED
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
 oracle.cep.logging.LogUtil log
INFO: Activate : DDL = alter system dump logging metadata_userfunc level 0,1,2,3
 oracle.cep.logging.LogUtil log
FINE: trace : area=METADATA_USERFUNC event=DUMP target=UserFunctionManager levels=0 1 2 3 
 oracle.cep.logging.LogUtil log
FINE:  <Event Name="DUMP" TargetId="0" TargetName="UserFunctionManager">
  <Level Name="STACKTRACE" Value="0">
   <Stacktrace>java.lang.Exception
	at oracle.cep.util.DebugUtil.getCurrentStackTrace
	at oracle.cep.logging.LogUtil.trace
	at oracle.cep.logging.LogLevelManager.dump
	at oracle.cep.logging.LogLevelManager.dumpLog
	at oracle.cep.server.CommandDriver.LoggingNodeDriver.execute
	at oracle.cep.server.CommandInterpreter.execute
	at oracle.cep.service.CEPManager.executeDDL
	at oracle.cep.service.CEPManager.ddlProcess
	at oracle.cep.service.CEPManager.activate
	at oracle.cep.service.CEPManager.activate
	at oracle.cep.service.CEPManager.runCqlx
	at oracle.cep.service.CEPManager.init
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
	at java.lang.reflect.Method.invoke
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons
	at org.springframework.context.support.AbstractApplicationContext.refresh
	at org.springframework.context.support.FileSystemXmlApplicationContext.<init>
	at org.springframework.context.support.FileSystemXmlApplicationContext.<init>
	at org.springframework.context.support.FileSystemXmlApplicationContext.<init>
	at TkCEPServer.main
</Stacktrace>
  </Level>
  <Level Name="MUSERFUNC_INFO" Value="2">
   <SingleFunctions >
    <SimpleFunction Key="ltet(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltrim(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltrim(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="incompleteBeta(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPIncompleteBeta</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIncompleteBeta</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function incompleteBeta(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPIncompleteBeta"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="poissonComplemented(int,double)">
     <implClass>oracle.cep.colt.functions.CEPPoissonComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPPoissonComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function poissonComplemented(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPPoissonComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="normal1(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPNormal1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNormal1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function normal1(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPNormal1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="abs2(float)">
     <implClass>oracle.cep.colt.functions.CEPAbs2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs2(c1 float) return float as language java name "oracle.cep.colt.functions.CEPAbs2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="negativeBinomial(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPNegativeBinomial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNegativeBinomial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function negativeBinomial(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPNegativeBinomial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="initcap(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function initcap(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="toRadians(double)">
     <implClass>oracle.cep.colt.functions.CEPToRadians</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPToRadians</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function toRadians(c1 double) return double as language java name "oracle.cep.colt.functions.CEPToRadians"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="hypot(double,double)">
     <implClass>oracle.cep.colt.functions.CEPHypot</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHypot</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hypot(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPHypot"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="divide(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 timestamp, c2 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="k1e(double)">
     <implClass>oracle.cep.colt.functions.CEPK1e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK1e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k1e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK1e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_double(float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_double(c1 float) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="cosh(double)">
     <implClass>oracle.cep.colt.functions.CEPCosh</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCosh</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function cosh(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCosh"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="multiply(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="signum1(float)">
     <implClass>oracle.cep.colt.functions.CEPSignum1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSignum1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function signum1(c1 float) return float as language java name "oracle.cep.colt.functions.CEPSignum1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="rpad(char,int,char)">
     <implClass>oracle.cep.extensibility.functions.builtin.Rpad</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Rpad</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rpad(c1 char, c2 int, c3 char) return char as language java name "oracle.cep.extensibility.functions.builtin.Rpad"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="multiply(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="expm1(double)">
     <implClass>oracle.cep.colt.functions.CEPExpm1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPExpm1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function expm1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPExpm1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_double(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_double(c1 bigint) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_timestamp(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_timestamp(c1 char) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="k0(double)">
     <implClass>oracle.cep.colt.functions.CEPK0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 interval, c2 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="hash2(int)">
     <implClass>oracle.cep.colt.functions.CEPHash2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash2(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPHash2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="tan(double)">
     <implClass>oracle.cep.colt.functions.CEPTan</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPTan</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function tan(c1 double) return double as language java name "oracle.cep.colt.functions.CEPTan"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="translate(char,char,char)">
     <implClass>oracle.cep.extensibility.functions.builtin.Translate</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Translate</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function translate(c1 char, c2 char, c3 char) return char as language java name "oracle.cep.extensibility.functions.builtin.Translate"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(float,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 float, n int) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="beta(double,double)">
     <implClass>oracle.cep.colt.functions.CEPBeta</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBeta</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function beta(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPBeta"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="systimestamp()">
     <implClass>null</implClass>
     <paramList >
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function systimestamp return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(byte,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 byte, n int, c3 int, c4 timestamp) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="logGamma(double)">
     <implClass>oracle.cep.colt.functions.CEPLogGamma</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLogGamma</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function logGamma(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLogGamma"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ulp(double)">
     <implClass>oracle.cep.colt.functions.CEPUlp</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPUlp</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ulp(c1 double) return double as language java name "oracle.cep.colt.functions.CEPUlp"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="sin(double)">
     <implClass>oracle.cep.colt.functions.CEPSin</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSin</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sin(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSin"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="toDegrees(double)">
     <implClass>oracle.cep.colt.functions.CEPToDegrees</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPToDegrees</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function toDegrees(c1 double) return double as language java name "oracle.cep.colt.functions.CEPToDegrees"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltrim(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltrim(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lower(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lower(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="leastSignificantBit(int)">
     <implClass>oracle.cep.colt.functions.CEPLeastSignificantBit</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLeastSignificantBit</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function leastSignificantBit(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPLeastSignificantBit"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="cos(double)">
     <implClass>oracle.cep.colt.functions.CEPCos</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCos</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function cos(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCos"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="length(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function length(c char) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="k0e(double)">
     <implClass>oracle.cep.colt.functions.CEPK0e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK0e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k0e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK0e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_float(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_float(c1 bigint) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="multiply(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="mostSignificantBit(int)">
     <implClass>oracle.cep.colt.functions.CEPMostSignificantBit</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPMostSignificantBit</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mostSignificantBit(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPMostSignificantBit"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="signum(double)">
     <implClass>oracle.cep.colt.functions.CEPSignum</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSignum</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function signum(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSignum"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="j0(double)">
     <implClass>oracle.cep.colt.functions.CEPJ0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPJ0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function j0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPJ0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ceil1(double)">
     <implClass>oracle.cep.colt.functions.CEPCeil1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCeil1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ceil1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCeil1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="abs(int)">
     <implClass>oracle.cep.colt.functions.CEPAbs</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPAbs"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ceil(double)">
     <implClass>oracle.cep.colt.functions.CEPCeil</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCeil</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ceil(c1 double) return bigint as language java name "oracle.cep.colt.functions.CEPCeil"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 timestamp, c2 timestamp) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(float,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 float, n int, c3 int, c4 timestamp) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="betaComplemented(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPBetaComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBetaComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function betaComplemented(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBetaComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="floor1(double)">
     <implClass>oracle.cep.colt.functions.CEPFloor1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPFloor1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function floor1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPFloor1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="concat(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function concat(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(int,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 int, n int, c3 int, c4 timestamp) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(timestamp,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 timestamp, c2 interval) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="k1(double)">
     <implClass>oracle.cep.colt.functions.CEPK1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="chiSquareComplemented(double,double)">
     <implClass>oracle.cep.colt.functions.CEPChiSquareComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPChiSquareComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function chiSquareComplemented(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPChiSquareComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="kn(int,double)">
     <implClass>oracle.cep.colt.functions.CEPKn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPKn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function kn(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPKn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="hextoraw(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hextoraw(c char) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="mod(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="hash1(float)">
     <implClass>oracle.cep.colt.functions.CEPHash1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash1(c1 float) return integer as language java name "oracle.cep.colt.functions.CEPHash1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="factorial(int)">
     <implClass>oracle.cep.colt.functions.CEPFactorial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPFactorial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function factorial(c1 integer) return double as language java name "oracle.cep.colt.functions.CEPFactorial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_float(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_float(c1 int) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="j1(double)">
     <implClass>oracle.cep.colt.functions.CEPJ1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPJ1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function j1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPJ1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="poisson(int,double)">
     <implClass>oracle.cep.colt.functions.CEPPoisson</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPPoisson</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function poisson(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPPoisson"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="mod(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="multiply(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="longFactorial(int)">
     <implClass>oracle.cep.colt.functions.CEPLongFactorial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLongFactorial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function longFactorial(c1 integer) return bigint as language java name "oracle.cep.colt.functions.CEPLongFactorial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 byte) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="exp(double)">
     <implClass>oracle.cep.colt.functions.CEPExp</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPExp</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function exp(c1 double) return double as language java name "oracle.cep.colt.functions.CEPExp"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="XMLQUERY(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>xmltype</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function XMLQUERY(c1 char) return xmltype as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="binomial(double,bigint)">
     <implClass>oracle.cep.colt.functions.CEPBinomial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomial(c1 double, c2 bigint) return double as language java name "oracle.cep.colt.functions.CEPBinomial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log10(double)">
     <implClass>oracle.cep.colt.functions.CEPLog10</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog10</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log10(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog10"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log1p(double)">
     <implClass>oracle.cep.colt.functions.CEPLog1p</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog1p</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log1p(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog1p"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="errorFunctionComplemented(double)">
     <implClass>oracle.cep.colt.functions.CEPErrorFunctionComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPErrorFunctionComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function errorFunctionComplemented(c1 double) return double as language java name "oracle.cep.colt.functions.CEPErrorFunctionComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="sqrt(double)">
     <implClass>oracle.cep.colt.functions.CEPSqrt</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSqrt</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sqrt(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSqrt"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="i0(double)">
     <implClass>oracle.cep.colt.functions.CEPI0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="divide(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="abs3(double)">
     <implClass>oracle.cep.colt.functions.CEPAbs3</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs3</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs3(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAbs3"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="beta1(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPBeta1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBeta1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function beta1(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBeta1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="substr(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function substr(c1 char, c2 int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log_xor(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_xor(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="pow(double,double)">
     <implClass>oracle.cep.colt.functions.CEPPow</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPPow</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function pow(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPPow"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="rawtohex(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>b</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rawtohex(b byte) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(char,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 char, n int, c3 int, c4 timestamp) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(interval,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 interval, c2 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="binomial1(bigint,bigint)">
     <implClass>oracle.cep.colt.functions.CEPBinomial1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomial1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomial1(c1 bigint, c2 bigint) return double as language java name "oracle.cep.colt.functions.CEPBinomial1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="normal(double)">
     <implClass>oracle.cep.colt.functions.CEPNormal</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNormal</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function normal(c1 double) return double as language java name "oracle.cep.colt.functions.CEPNormal"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="yn(int,double)">
     <implClass>oracle.cep.colt.functions.CEPYn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPYn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function yn(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPYn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(byte,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 byte, n int) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 interval, c2 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="floor(double)">
     <implClass>oracle.cep.colt.functions.CEPFloor</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPFloor</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function floor(c1 double) return bigint as language java name "oracle.cep.colt.functions.CEPFloor"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="stirlingCorrection(int)">
     <implClass>oracle.cep.colt.functions.CEPStirlingCorrection</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPStirlingCorrection</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function stirlingCorrection(c1 integer) return double as language java name "oracle.cep.colt.functions.CEPStirlingCorrection"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="mod(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="i1(double)">
     <implClass>oracle.cep.colt.functions.CEPI1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="hash(double)">
     <implClass>oracle.cep.colt.functions.CEPHash</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash(c1 double) return integer as language java name "oracle.cep.colt.functions.CEPHash"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="concat(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>b1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>b2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function concat(b1 byte, b2 byte) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="plus(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 interval, c2 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="upper(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function upper(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="errorFunction(double)">
     <implClass>oracle.cep.colt.functions.CEPErrorFunction</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPErrorFunction</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function errorFunction(c1 double) return double as language java name "oracle.cep.colt.functions.CEPErrorFunction"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="incompleteGammaComplement(double,double)">
     <implClass>oracle.cep.colt.functions.CEPIncompleteGammaComplement</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIncompleteGammaComplement</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function incompleteGammaComplement(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPIncompleteGammaComplement"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(interval,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 interval, n int) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_timestamp(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_timestamp(c1 char, c2 char) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="atan(double)">
     <implClass>oracle.cep.colt.functions.CEPAtan</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAtan</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function atan(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAtan"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="abs1(bigint)">
     <implClass>oracle.cep.colt.functions.CEPAbs1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs1(c1 bigint) return bigint as language java name "oracle.cep.colt.functions.CEPAbs1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lk(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lk(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(bigint,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 bigint, n int, c3 int, c4 timestamp) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="asin(double)">
     <implClass>oracle.cep.colt.functions.CEPAsin</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAsin</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function asin(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAsin"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="mod(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="bitMaskWithBitsSetFromTo(int,int)">
     <implClass>oracle.cep.colt.functions.CEPBitMaskWithBitsSetFromTo</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBitMaskWithBitsSetFromTo</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function bitMaskWithBitsSetFromTo(c1 integer, c2 integer) return bigint as language java name "oracle.cep.colt.functions.CEPBitMaskWithBitsSetFromTo"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log1(double)">
     <implClass>oracle.cep.colt.functions.CEPLog1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log_or(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_or(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="hash3(bigint)">
     <implClass>oracle.cep.colt.functions.CEPHash3</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash3</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash3(c1 bigint) return integer as language java name "oracle.cep.colt.functions.CEPHash3"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="rpad(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rpad(c1 char, c2 int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="y0(double)">
     <implClass>oracle.cep.colt.functions.CEPY0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPY0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function y0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPY0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="XMLEXISTS(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function XMLEXISTS(c1 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="jn(int,double)">
     <implClass>oracle.cep.colt.functions.CEPJn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPJn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function jn(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPJn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="acos(double)">
     <implClass>oracle.cep.colt.functions.CEPAcos</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAcos</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function acos(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAcos"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 int, n int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="binomialComplemented(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPBinomialComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomialComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomialComplemented(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBinomialComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="incompleteGamma(double,double)">
     <implClass>oracle.cep.colt.functions.CEPIncompleteGamma</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIncompleteGamma</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function incompleteGamma(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPIncompleteGamma"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="rtrim(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rtrim(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log(double,double)">
     <implClass>oracle.cep.colt.functions.CEPLog</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPLog"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="chiSquare(double,double)">
     <implClass>oracle.cep.colt.functions.CEPChiSquare</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPChiSquare</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function chiSquare(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPChiSquare"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gamma1(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPGamma1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGamma1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gamma1(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPGamma1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log_not(boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_not(c1 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lpad(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lpad(c1 char, c2 int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gamma(double)">
     <implClass>oracle.cep.colt.functions.CEPGamma</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGamma</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gamma(c1 double) return double as language java name "oracle.cep.colt.functions.CEPGamma"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="tanh(double)">
     <implClass>oracle.cep.colt.functions.CEPTanh</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPTanh</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function tanh(c1 double) return double as language java name "oracle.cep.colt.functions.CEPTanh"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="normalInverse(double)">
     <implClass>oracle.cep.colt.functions.CEPNormalInverse</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNormalInverse</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function normalInverse(c1 double) return double as language java name "oracle.cep.colt.functions.CEPNormalInverse"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="getSeedAtRowColumn(int,int)">
     <implClass>oracle.cep.colt.functions.CEPGetSeedAtRowColumn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGetSeedAtRowColumn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function getSeedAtRowColumn(c1 integer, c2 integer) return integer as language java name "oracle.cep.colt.functions.CEPGetSeedAtRowColumn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="round(float)">
     <implClass>oracle.cep.colt.functions.CEPRound</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPRound</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function round(c1 float) return integer as language java name "oracle.cep.colt.functions.CEPRound"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="negativeBinomialComplemented(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPNegativeBinomialComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNegativeBinomialComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function negativeBinomialComplemented(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPNegativeBinomialComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log2(double)">
     <implClass>oracle.cep.colt.functions.CEPLog2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log2(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="y1(double)">
     <implClass>oracle.cep.colt.functions.CEPY1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPY1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function y1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPY1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="round1(double)">
     <implClass>oracle.cep.colt.functions.CEPRound1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPRound1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function round1(c1 double) return bigint as language java name "oracle.cep.colt.functions.CEPRound1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log101(double)">
     <implClass>oracle.cep.colt.functions.CEPLog101</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog101</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log101(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog101"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="studentT(double,double)">
     <implClass>oracle.cep.colt.functions.CEPStudentT</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPStudentT</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function studentT(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPStudentT"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="cbrt(double)">
     <implClass>oracle.cep.colt.functions.CEPCbrt</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCbrt</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function cbrt(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCbrt"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="binomial2(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPBinomial2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomial2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomial2(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBinomial2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="IEEEremainder(double,double)">
     <implClass>oracle.cep.colt.functions.CEPIEEEremainder</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIEEEremainder</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function IEEEremainder(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPIEEEremainder"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_bigint(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_bigint(c1 int) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(bigint,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 bigint, n int) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="studentTInverse(double,int)">
     <implClass>oracle.cep.colt.functions.CEPStudentTInverse</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPStudentTInverse</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function studentTInverse(c1 double, c2 integer) return double as language java name "oracle.cep.colt.functions.CEPStudentTInverse"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ltet(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="rtrim(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rtrim(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gammaComplemented(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPGammaComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGammaComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gammaComplemented(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPGammaComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lt(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="rint(double)">
     <implClass>oracle.cep.colt.functions.CEPRint</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPRint</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rint(c1 double) return double as language java name "oracle.cep.colt.functions.CEPRint"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="sinh(double)">
     <implClass>oracle.cep.colt.functions.CEPSinh</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSinh</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sinh(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSinh"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(interval,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 interval, n int, c3 int, c4 timestamp) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="substr(char,int,int)">
     <implClass>oracle.cep.extensibility.functions.builtin.SubStr</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.SubStr</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function substr(c1 char, c2 int, c3 int) return char as language java name "oracle.cep.extensibility.functions.builtin.SubStr"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="length(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>b</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function length(b byte) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="divide(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="i1e(double)">
     <implClass>oracle.cep.colt.functions.CEPI1e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI1e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i1e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI1e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="is_null(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(timestamp,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 timestamp, c2 interval) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="lpad(char,int,char)">
     <implClass>oracle.cep.extensibility.functions.builtin.Lpad</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Lpad</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lpad(c1 char, c2 int, c3 char) return char as language java name "oracle.cep.extensibility.functions.builtin.Lpad"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="atan2(double,double)">
     <implClass>oracle.cep.colt.functions.CEPAtan2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAtan2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function atan2(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPAtan2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="subtract(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="net(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(double,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 double, n int, c3 int, c4 timestamp) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(timestamp,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 timestamp, n int) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="i0e(double)">
     <implClass>oracle.cep.colt.functions.CEPI0e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI0e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i0e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI0e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="logFactorial(int)">
     <implClass>oracle.cep.colt.functions.CEPLogFactorial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLogFactorial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function logFactorial(c1 integer) return double as language java name "oracle.cep.colt.functions.CEPLogFactorial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="et(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 char, n int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="ulp1(float)">
     <implClass>oracle.cep.colt.functions.CEPUlp1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.colt.functions.CEPUlp1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ulp1(c1 float) return float as language java name "oracle.cep.colt.functions.CEPUlp1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="divide(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="to_double(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_double(c1 int) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gtet(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(double,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 double, n int) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="gt(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="log_and(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_and(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="prev(timestamp,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 timestamp, n int, c3 int, c4 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
    <SimpleFunction Key="nvl(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 byte, c2 byte) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunction>
   </SingleFunctions>
   <SimpleFunctions >
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>385</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>431</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>253</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>411</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>219</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>255</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>23</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>263</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>281</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>313</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>128</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>41</funcsElem>
      <funcsElem>43</funcsElem>
      <funcsElem>44</funcsElem>
      <funcsElem>45</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>351</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>403</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>285</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>423</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>5</funcsElem>
      <funcsElem>7</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>339</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>108</funcsElem>
      <funcsElem>110</funcsElem>
      <funcsElem>111</funcsElem>
      <funcsElem>112</funcsElem>
      <funcsElem>113</funcsElem>
      <funcsElem>114</funcsElem>
      <funcsElem>115</funcsElem>
      <funcsElem>116</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>345</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>299</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>10</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>283</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>399</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>249</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>130</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>409</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>217</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>259</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>251</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>261</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>279</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>257</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>363</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>311</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>25</funcsElem>
      <funcsElem>27</funcsElem>
      <funcsElem>28</funcsElem>
      <funcsElem>29</funcsElem>
      <funcsElem>30</funcsElem>
      <funcsElem>31</funcsElem>
      <funcsElem>32</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>297</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>134</funcsElem>
      <funcsElem>136</funcsElem>
      <funcsElem>137</funcsElem>
      <funcsElem>138</funcsElem>
      <funcsElem>139</funcsElem>
      <funcsElem>140</funcsElem>
      <funcsElem>141</funcsElem>
      <funcsElem>142</funcsElem>
      <funcsElem>143</funcsElem>
      <funcsElem>144</funcsElem>
      <funcsElem>145</funcsElem>
      <funcsElem>146</funcsElem>
      <funcsElem>147</funcsElem>
      <funcsElem>148</funcsElem>
      <funcsElem>149</funcsElem>
      <funcsElem>150</funcsElem>
      <funcsElem>151</funcsElem>
      <funcsElem>152</funcsElem>
      <funcsElem>153</funcsElem>
      <funcsElem>154</funcsElem>
      <funcsElem>155</funcsElem>
      <funcsElem>156</funcsElem>
      <funcsElem>157</funcsElem>
      <funcsElem>158</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>122</funcsElem>
      <funcsElem>124</funcsElem>
      <funcsElem>125</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>365</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>353</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>393</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>397</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>307</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>221</funcsElem>
      <funcsElem>223</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>287</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>232</funcsElem>
      <funcsElem>234</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>383</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>12</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>117</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>377</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>213</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>379</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>289</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>99</funcsElem>
      <funcsElem>101</funcsElem>
      <funcsElem>102</funcsElem>
      <funcsElem>103</funcsElem>
      <funcsElem>104</funcsElem>
      <funcsElem>105</funcsElem>
      <funcsElem>106</funcsElem>
      <funcsElem>107</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>381</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>331</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>335</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>329</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>245</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>413</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>341</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>395</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>407</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>51</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>3</funcsElem>
      <funcsElem>9</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>375</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>1</funcsElem>
      <funcsElem>8</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>333</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>132</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>415</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>14</funcsElem>
      <funcsElem>16</funcsElem>
      <funcsElem>17</funcsElem>
      <funcsElem>18</funcsElem>
      <funcsElem>19</funcsElem>
      <funcsElem>20</funcsElem>
      <funcsElem>21</funcsElem>
      <funcsElem>22</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>425</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>235</funcsElem>
      <funcsElem>237</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>355</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>53</funcsElem>
      <funcsElem>55</funcsElem>
      <funcsElem>56</funcsElem>
      <funcsElem>57</funcsElem>
      <funcsElem>58</funcsElem>
      <funcsElem>59</funcsElem>
      <funcsElem>60</funcsElem>
      <funcsElem>61</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>417</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>301</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>419</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>62</funcsElem>
      <funcsElem>64</funcsElem>
      <funcsElem>65</funcsElem>
      <funcsElem>66</funcsElem>
      <funcsElem>67</funcsElem>
      <funcsElem>68</funcsElem>
      <funcsElem>69</funcsElem>
      <funcsElem>70</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>321</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>89</funcsElem>
      <funcsElem>91</funcsElem>
      <funcsElem>92</funcsElem>
      <funcsElem>93</funcsElem>
      <funcsElem>94</funcsElem>
      <funcsElem>95</funcsElem>
      <funcsElem>96</funcsElem>
      <funcsElem>97</funcsElem>
      <funcsElem>98</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>347</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>305</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>315</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>343</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>229</funcsElem>
      <funcsElem>231</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>391</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>309</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>401</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>389</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>427</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>371</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>349</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>323</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>224</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>269</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>265</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>327</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>291</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>46</funcsElem>
      <funcsElem>48</funcsElem>
      <funcsElem>49</funcsElem>
      <funcsElem>50</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>271</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>293</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>126</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>337</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>33</funcsElem>
      <funcsElem>35</funcsElem>
      <funcsElem>36</funcsElem>
      <funcsElem>37</funcsElem>
      <funcsElem>38</funcsElem>
      <funcsElem>39</funcsElem>
      <funcsElem>40</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>215</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>369</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>429</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>367</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>238</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>247</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>405</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>319</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>273</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>303</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>421</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>71</funcsElem>
      <funcsElem>73</funcsElem>
      <funcsElem>74</funcsElem>
      <funcsElem>75</funcsElem>
      <funcsElem>76</funcsElem>
      <funcsElem>77</funcsElem>
      <funcsElem>78</funcsElem>
      <funcsElem>79</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>119</funcsElem>
      <funcsElem>121</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>267</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>275</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>357</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>295</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>80</funcsElem>
      <funcsElem>82</funcsElem>
      <funcsElem>83</funcsElem>
      <funcsElem>84</funcsElem>
      <funcsElem>85</funcsElem>
      <funcsElem>86</funcsElem>
      <funcsElem>87</funcsElem>
      <funcsElem>88</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>277</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>359</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>226</funcsElem>
      <funcsElem>228</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>373</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>361</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>240</funcsElem>
      <funcsElem>242</funcsElem>
      <funcsElem>243</funcsElem>
      <funcsElem>244</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>325</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>317</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>387</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </SimpleFunctionSet>
   </SimpleFunctions>
   <AggrFunctions >
    <AggFunction Key="trimmedMean(double,int,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPTrimmedMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  trimmedMean(c1 double, c2 int, c3 int) return double  aggregate using "oracle.cep.colt.aggr.CEPTrimmedMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="SUM(float)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 float) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="autoCorrelation(double,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPAutoCorrelation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  autoCorrelation(c1 double, c2 int) return double  aggregate using "oracle.cep.colt.aggr.CEPAutoCorrelation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(byte)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 byte) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="AVG(bigint)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 bigint) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(char)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 char) return char aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(bigint)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 bigint) return bigint aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 double) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(timestamp)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 timestamp) return timestamp aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(char)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 char) return char aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sumOfSquares(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfSquares</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfSquares(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfSquares" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sampleStandardDeviation(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleStandardDeviation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleStandardDeviation(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleStandardDeviation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(timestamp)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 timestamp) return timestamp aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sumOfInversions(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfInversions</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfInversions(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfInversions" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(float)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 float) return float aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sumOfSquaredDeviations(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfSquaredDeviations</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfSquaredDeviations(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfSquaredDeviations" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(interval)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 interval) return interval aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sumOfPowerDeviations(double,int,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfPowerDeviations</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfPowerDeviations(c1 double, c2 int, c3 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfPowerDeviations" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(char)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 char) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="kurtosis(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPKurtosis</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  kurtosis(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPKurtosis" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sumOfPowers(double,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfPowers</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfPowers(c1 double, c2 int) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfPowers" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(byte,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 byte, n int) return byte aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(interval)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 interval) return interval aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(int,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 int, n int) return int aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="moment(double,int,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMoment</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  moment(c1 double, c2 int, c3 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMoment" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 int) return int aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(float)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
      <destQueriesElem>494</destQueriesElem>
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 float) return float aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(float)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 float) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="variance(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPVariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  variance(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPVariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="lag1(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPLag1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  lag1(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPLag1" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="median(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMedian</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  median(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMedian" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(char,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 char, n int) return char aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="SUM(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 double) return double aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(interval)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 interval) return interval aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="meanDeviation(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMeanDeviation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  meanDeviation(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMeanDeviation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(bigint)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 bigint) return bigint aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(interval,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 interval, n int) return interval aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="correlation(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPCorrelation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  correlation(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPCorrelation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="AVG(float)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 float) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sampleKurtosisStandardError(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleKurtosisStandardError</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleKurtosisStandardError(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleKurtosisStandardError" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sampleSkew(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleSkew</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleSkew(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleSkew" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sampleSkewStandardError(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleSkewStandardError</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleSkewStandardError(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleSkewStandardError" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(bigint,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 bigint, n int) return bigint aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(float,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 float, n int) return float aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="weightedMean(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPWeightedMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  weightedMean(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPWeightedMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(bigint)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 bigint) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="rms(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPRms</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  rms(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPRms" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(int,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 int, n int) return int aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(float)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 float) return float aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="pooledMean(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPPooledMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  pooledMean(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPPooledMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="standardError(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPStandardError</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  standardError(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPStandardError" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="winsorizedMean(double,int,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPWinsorizedMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  winsorizedMean(c1 double, c2 int, c3 int) return double  aggregate using "oracle.cep.colt.aggr.CEPWinsorizedMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(timestamp)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 timestamp) return timestamp aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 int) return int aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(double,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 double, n int) return double aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="geometricMean(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPGeometricMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  geometricMean(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPGeometricMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(timestamp,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 timestamp, n int) return timestamp aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(float,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 float, n int) return float aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="SUM(int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 int) return int aggregate using "$dummy" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="product(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPProduct</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  product(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPProduct" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 int) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="rankInterpolated(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPRankInterpolated</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  rankInterpolated(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPRankInterpolated" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="skew(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSkew</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  skew(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSkew" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="AVG(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 double) return double aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="pooledVariance(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPPooledVariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  pooledVariance(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPPooledVariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(double)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 double) return double aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="geometricMean1(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPGeometricMean1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  geometricMean1(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPGeometricMean1" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="durbinWatson(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPDurbinWatson</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  durbinWatson(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPDurbinWatson" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(byte)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 byte) return byte aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(timestamp)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 timestamp) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(byte)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 byte) return byte aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="SUM(bigint)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 bigint) return bigint aggregate using "$dummy" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="standardDeviation(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPStandardDeviation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  standardDeviation(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPStandardDeviation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(char,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 char, n int) return char aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(byte,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 byte, n int) return byte aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="AVG(int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 int) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MAX(byte)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 byte) return byte aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="COUNT(interval)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 interval) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sampleKurtosis(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleKurtosis</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleKurtosis(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleKurtosis" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(bigint,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 bigint, n int) return bigint aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="quantile(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPQuantile</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  quantile(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPQuantile" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(timestamp,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 timestamp, n int) return timestamp aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sumOfLogarithms(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfLogarithms</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfLogarithms(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfLogarithms" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(char)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 char) return char aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="covariance(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPCovariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  covariance(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPCovariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="mean(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  mean(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="harmonicMean(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPHarmonicMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  harmonicMean(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPHarmonicMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="quantileInverse(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPQuantileInverse</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  quantileInverse(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPQuantileInverse" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="sampleVariance(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleVariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleVariance(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleVariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="MIN(double)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 double) return double aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="LAST(double,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 double, n int) return double aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
    <AggFunction Key="FIRST(interval,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 interval, n int) return interval aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
    </AggFunction>
   </AggrFunctions>
  </Level>
  <Level Name="MUSERFUNC_LOCKINFO" Value="3">
   <SingleFunctions >
    <SimpleFunction Key="ltet(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltrim(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltrim(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="incompleteBeta(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPIncompleteBeta</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIncompleteBeta</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function incompleteBeta(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPIncompleteBeta"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="poissonComplemented(int,double)">
     <implClass>oracle.cep.colt.functions.CEPPoissonComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPPoissonComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function poissonComplemented(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPPoissonComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="normal1(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPNormal1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNormal1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function normal1(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPNormal1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="abs2(float)">
     <implClass>oracle.cep.colt.functions.CEPAbs2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs2(c1 float) return float as language java name "oracle.cep.colt.functions.CEPAbs2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="negativeBinomial(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPNegativeBinomial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNegativeBinomial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function negativeBinomial(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPNegativeBinomial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="initcap(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function initcap(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="toRadians(double)">
     <implClass>oracle.cep.colt.functions.CEPToRadians</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPToRadians</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function toRadians(c1 double) return double as language java name "oracle.cep.colt.functions.CEPToRadians"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="hypot(double,double)">
     <implClass>oracle.cep.colt.functions.CEPHypot</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHypot</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hypot(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPHypot"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="divide(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 timestamp, c2 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="k1e(double)">
     <implClass>oracle.cep.colt.functions.CEPK1e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK1e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k1e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK1e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_double(float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_double(c1 float) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="cosh(double)">
     <implClass>oracle.cep.colt.functions.CEPCosh</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCosh</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function cosh(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCosh"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="multiply(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="signum1(float)">
     <implClass>oracle.cep.colt.functions.CEPSignum1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSignum1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function signum1(c1 float) return float as language java name "oracle.cep.colt.functions.CEPSignum1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="rpad(char,int,char)">
     <implClass>oracle.cep.extensibility.functions.builtin.Rpad</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Rpad</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rpad(c1 char, c2 int, c3 char) return char as language java name "oracle.cep.extensibility.functions.builtin.Rpad"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="multiply(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="expm1(double)">
     <implClass>oracle.cep.colt.functions.CEPExpm1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPExpm1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function expm1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPExpm1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_double(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_double(c1 bigint) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_timestamp(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_timestamp(c1 char) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="k0(double)">
     <implClass>oracle.cep.colt.functions.CEPK0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 interval, c2 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="hash2(int)">
     <implClass>oracle.cep.colt.functions.CEPHash2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash2(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPHash2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="tan(double)">
     <implClass>oracle.cep.colt.functions.CEPTan</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPTan</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function tan(c1 double) return double as language java name "oracle.cep.colt.functions.CEPTan"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="translate(char,char,char)">
     <implClass>oracle.cep.extensibility.functions.builtin.Translate</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Translate</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function translate(c1 char, c2 char, c3 char) return char as language java name "oracle.cep.extensibility.functions.builtin.Translate"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(float,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 float, n int) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="beta(double,double)">
     <implClass>oracle.cep.colt.functions.CEPBeta</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBeta</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function beta(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPBeta"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="systimestamp()">
     <implClass>null</implClass>
     <paramList >
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function systimestamp return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(byte,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 byte, n int, c3 int, c4 timestamp) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="logGamma(double)">
     <implClass>oracle.cep.colt.functions.CEPLogGamma</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLogGamma</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function logGamma(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLogGamma"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ulp(double)">
     <implClass>oracle.cep.colt.functions.CEPUlp</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPUlp</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ulp(c1 double) return double as language java name "oracle.cep.colt.functions.CEPUlp"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="sin(double)">
     <implClass>oracle.cep.colt.functions.CEPSin</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSin</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sin(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSin"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="toDegrees(double)">
     <implClass>oracle.cep.colt.functions.CEPToDegrees</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPToDegrees</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function toDegrees(c1 double) return double as language java name "oracle.cep.colt.functions.CEPToDegrees"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltrim(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltrim(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lower(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lower(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="leastSignificantBit(int)">
     <implClass>oracle.cep.colt.functions.CEPLeastSignificantBit</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLeastSignificantBit</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function leastSignificantBit(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPLeastSignificantBit"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="cos(double)">
     <implClass>oracle.cep.colt.functions.CEPCos</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCos</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function cos(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCos"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="length(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function length(c char) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="k0e(double)">
     <implClass>oracle.cep.colt.functions.CEPK0e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK0e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k0e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK0e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_float(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_float(c1 bigint) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="multiply(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="mostSignificantBit(int)">
     <implClass>oracle.cep.colt.functions.CEPMostSignificantBit</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPMostSignificantBit</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mostSignificantBit(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPMostSignificantBit"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="signum(double)">
     <implClass>oracle.cep.colt.functions.CEPSignum</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSignum</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function signum(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSignum"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="j0(double)">
     <implClass>oracle.cep.colt.functions.CEPJ0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPJ0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function j0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPJ0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ceil1(double)">
     <implClass>oracle.cep.colt.functions.CEPCeil1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCeil1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ceil1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCeil1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="abs(int)">
     <implClass>oracle.cep.colt.functions.CEPAbs</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs(c1 integer) return integer as language java name "oracle.cep.colt.functions.CEPAbs"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ceil(double)">
     <implClass>oracle.cep.colt.functions.CEPCeil</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCeil</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ceil(c1 double) return bigint as language java name "oracle.cep.colt.functions.CEPCeil"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 timestamp, c2 timestamp) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(float,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 float, n int, c3 int, c4 timestamp) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="betaComplemented(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPBetaComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBetaComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function betaComplemented(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBetaComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="floor1(double)">
     <implClass>oracle.cep.colt.functions.CEPFloor1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPFloor1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function floor1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPFloor1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="concat(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function concat(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(int,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 int, n int, c3 int, c4 timestamp) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(timestamp,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 timestamp, c2 interval) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="k1(double)">
     <implClass>oracle.cep.colt.functions.CEPK1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPK1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function k1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPK1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="chiSquareComplemented(double,double)">
     <implClass>oracle.cep.colt.functions.CEPChiSquareComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPChiSquareComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function chiSquareComplemented(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPChiSquareComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="kn(int,double)">
     <implClass>oracle.cep.colt.functions.CEPKn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPKn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function kn(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPKn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="hextoraw(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hextoraw(c char) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="mod(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="hash1(float)">
     <implClass>oracle.cep.colt.functions.CEPHash1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash1(c1 float) return integer as language java name "oracle.cep.colt.functions.CEPHash1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="factorial(int)">
     <implClass>oracle.cep.colt.functions.CEPFactorial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPFactorial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function factorial(c1 integer) return double as language java name "oracle.cep.colt.functions.CEPFactorial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_float(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_float(c1 int) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="j1(double)">
     <implClass>oracle.cep.colt.functions.CEPJ1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPJ1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function j1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPJ1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="poisson(int,double)">
     <implClass>oracle.cep.colt.functions.CEPPoisson</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPPoisson</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function poisson(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPPoisson"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="mod(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="multiply(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function multiply(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="longFactorial(int)">
     <implClass>oracle.cep.colt.functions.CEPLongFactorial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLongFactorial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function longFactorial(c1 integer) return bigint as language java name "oracle.cep.colt.functions.CEPLongFactorial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 byte) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="exp(double)">
     <implClass>oracle.cep.colt.functions.CEPExp</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPExp</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function exp(c1 double) return double as language java name "oracle.cep.colt.functions.CEPExp"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="XMLQUERY(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>xmltype</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function XMLQUERY(c1 char) return xmltype as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="binomial(double,bigint)">
     <implClass>oracle.cep.colt.functions.CEPBinomial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomial(c1 double, c2 bigint) return double as language java name "oracle.cep.colt.functions.CEPBinomial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log10(double)">
     <implClass>oracle.cep.colt.functions.CEPLog10</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog10</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log10(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog10"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log1p(double)">
     <implClass>oracle.cep.colt.functions.CEPLog1p</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog1p</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log1p(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog1p"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="errorFunctionComplemented(double)">
     <implClass>oracle.cep.colt.functions.CEPErrorFunctionComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPErrorFunctionComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function errorFunctionComplemented(c1 double) return double as language java name "oracle.cep.colt.functions.CEPErrorFunctionComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="sqrt(double)">
     <implClass>oracle.cep.colt.functions.CEPSqrt</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSqrt</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sqrt(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSqrt"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="i0(double)">
     <implClass>oracle.cep.colt.functions.CEPI0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="divide(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="abs3(double)">
     <implClass>oracle.cep.colt.functions.CEPAbs3</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs3</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs3(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAbs3"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="beta1(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPBeta1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBeta1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function beta1(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBeta1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="substr(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function substr(c1 char, c2 int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log_xor(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_xor(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="pow(double,double)">
     <implClass>oracle.cep.colt.functions.CEPPow</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPPow</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function pow(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPPow"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="rawtohex(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>b</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rawtohex(b byte) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(char,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 char, n int, c3 int, c4 timestamp) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 int, c2 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(interval,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 interval, c2 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="binomial1(bigint,bigint)">
     <implClass>oracle.cep.colt.functions.CEPBinomial1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomial1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomial1(c1 bigint, c2 bigint) return double as language java name "oracle.cep.colt.functions.CEPBinomial1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="normal(double)">
     <implClass>oracle.cep.colt.functions.CEPNormal</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNormal</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function normal(c1 double) return double as language java name "oracle.cep.colt.functions.CEPNormal"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="yn(int,double)">
     <implClass>oracle.cep.colt.functions.CEPYn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPYn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function yn(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPYn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(byte,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 byte, n int) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 interval, c2 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="floor(double)">
     <implClass>oracle.cep.colt.functions.CEPFloor</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPFloor</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function floor(c1 double) return bigint as language java name "oracle.cep.colt.functions.CEPFloor"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="stirlingCorrection(int)">
     <implClass>oracle.cep.colt.functions.CEPStirlingCorrection</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPStirlingCorrection</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function stirlingCorrection(c1 integer) return double as language java name "oracle.cep.colt.functions.CEPStirlingCorrection"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="mod(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="i1(double)">
     <implClass>oracle.cep.colt.functions.CEPI1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="hash(double)">
     <implClass>oracle.cep.colt.functions.CEPHash</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash(c1 double) return integer as language java name "oracle.cep.colt.functions.CEPHash"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="concat(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>b1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>b2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function concat(b1 byte, b2 byte) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="plus(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function plus(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 bigint, c2 bigint) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 interval, c2 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="upper(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function upper(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="errorFunction(double)">
     <implClass>oracle.cep.colt.functions.CEPErrorFunction</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPErrorFunction</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function errorFunction(c1 double) return double as language java name "oracle.cep.colt.functions.CEPErrorFunction"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="incompleteGammaComplement(double,double)">
     <implClass>oracle.cep.colt.functions.CEPIncompleteGammaComplement</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIncompleteGammaComplement</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function incompleteGammaComplement(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPIncompleteGammaComplement"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(interval,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 interval, n int) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_timestamp(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_timestamp(c1 char, c2 char) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="atan(double)">
     <implClass>oracle.cep.colt.functions.CEPAtan</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAtan</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function atan(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAtan"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="abs1(bigint)">
     <implClass>oracle.cep.colt.functions.CEPAbs1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAbs1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function abs1(c1 bigint) return bigint as language java name "oracle.cep.colt.functions.CEPAbs1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lk(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lk(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 char, c2 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(bigint,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 bigint, n int, c3 int, c4 timestamp) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="asin(double)">
     <implClass>oracle.cep.colt.functions.CEPAsin</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAsin</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function asin(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAsin"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="mod(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function mod(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 interval) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="bitMaskWithBitsSetFromTo(int,int)">
     <implClass>oracle.cep.colt.functions.CEPBitMaskWithBitsSetFromTo</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBitMaskWithBitsSetFromTo</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function bitMaskWithBitsSetFromTo(c1 integer, c2 integer) return bigint as language java name "oracle.cep.colt.functions.CEPBitMaskWithBitsSetFromTo"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log1(double)">
     <implClass>oracle.cep.colt.functions.CEPLog1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log_or(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_or(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="hash3(bigint)">
     <implClass>oracle.cep.colt.functions.CEPHash3</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPHash3</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function hash3(c1 bigint) return integer as language java name "oracle.cep.colt.functions.CEPHash3"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="rpad(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rpad(c1 char, c2 int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="y0(double)">
     <implClass>oracle.cep.colt.functions.CEPY0</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPY0</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function y0(c1 double) return double as language java name "oracle.cep.colt.functions.CEPY0"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="XMLEXISTS(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function XMLEXISTS(c1 char) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="jn(int,double)">
     <implClass>oracle.cep.colt.functions.CEPJn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPJn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function jn(c1 integer, c2 double) return double as language java name "oracle.cep.colt.functions.CEPJn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="acos(double)">
     <implClass>oracle.cep.colt.functions.CEPAcos</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAcos</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function acos(c1 double) return double as language java name "oracle.cep.colt.functions.CEPAcos"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 int, n int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="binomialComplemented(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPBinomialComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomialComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomialComplemented(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBinomialComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="incompleteGamma(double,double)">
     <implClass>oracle.cep.colt.functions.CEPIncompleteGamma</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIncompleteGamma</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function incompleteGamma(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPIncompleteGamma"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="rtrim(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rtrim(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 int) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log(double,double)">
     <implClass>oracle.cep.colt.functions.CEPLog</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPLog"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(char,char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 char, c2 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="chiSquare(double,double)">
     <implClass>oracle.cep.colt.functions.CEPChiSquare</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPChiSquare</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function chiSquare(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPChiSquare"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gamma1(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPGamma1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGamma1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gamma1(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPGamma1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log_not(boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_not(c1 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lpad(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lpad(c1 char, c2 int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gamma(double)">
     <implClass>oracle.cep.colt.functions.CEPGamma</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGamma</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gamma(c1 double) return double as language java name "oracle.cep.colt.functions.CEPGamma"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="tanh(double)">
     <implClass>oracle.cep.colt.functions.CEPTanh</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPTanh</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function tanh(c1 double) return double as language java name "oracle.cep.colt.functions.CEPTanh"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="normalInverse(double)">
     <implClass>oracle.cep.colt.functions.CEPNormalInverse</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNormalInverse</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function normalInverse(c1 double) return double as language java name "oracle.cep.colt.functions.CEPNormalInverse"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="getSeedAtRowColumn(int,int)">
     <implClass>oracle.cep.colt.functions.CEPGetSeedAtRowColumn</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGetSeedAtRowColumn</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function getSeedAtRowColumn(c1 integer, c2 integer) return integer as language java name "oracle.cep.colt.functions.CEPGetSeedAtRowColumn"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="round(float)">
     <implClass>oracle.cep.colt.functions.CEPRound</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.colt.functions.CEPRound</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function round(c1 float) return integer as language java name "oracle.cep.colt.functions.CEPRound"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="negativeBinomialComplemented(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPNegativeBinomialComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPNegativeBinomialComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function negativeBinomialComplemented(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPNegativeBinomialComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log2(double)">
     <implClass>oracle.cep.colt.functions.CEPLog2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log2(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="y1(double)">
     <implClass>oracle.cep.colt.functions.CEPY1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPY1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function y1(c1 double) return double as language java name "oracle.cep.colt.functions.CEPY1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="round1(double)">
     <implClass>oracle.cep.colt.functions.CEPRound1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.colt.functions.CEPRound1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function round1(c1 double) return bigint as language java name "oracle.cep.colt.functions.CEPRound1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log101(double)">
     <implClass>oracle.cep.colt.functions.CEPLog101</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLog101</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log101(c1 double) return double as language java name "oracle.cep.colt.functions.CEPLog101"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="studentT(double,double)">
     <implClass>oracle.cep.colt.functions.CEPStudentT</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPStudentT</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function studentT(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPStudentT"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="cbrt(double)">
     <implClass>oracle.cep.colt.functions.CEPCbrt</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPCbrt</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function cbrt(c1 double) return double as language java name "oracle.cep.colt.functions.CEPCbrt"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="binomial2(int,int,double)">
     <implClass>oracle.cep.colt.functions.CEPBinomial2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPBinomial2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function binomial2(c1 integer, c2 integer, c3 double) return double as language java name "oracle.cep.colt.functions.CEPBinomial2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="IEEEremainder(double,double)">
     <implClass>oracle.cep.colt.functions.CEPIEEEremainder</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPIEEEremainder</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function IEEEremainder(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPIEEEremainder"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_bigint(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_bigint(c1 int) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(bigint,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 bigint, n int) return bigint as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="studentTInverse(double,int)">
     <implClass>oracle.cep.colt.functions.CEPStudentTInverse</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPStudentTInverse</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function studentTInverse(c1 double, c2 integer) return double as language java name "oracle.cep.colt.functions.CEPStudentTInverse"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ltet(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ltet(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="rtrim(char)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rtrim(c1 char) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gammaComplemented(double,double,double)">
     <implClass>oracle.cep.colt.functions.CEPGammaComplemented</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPGammaComplemented</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gammaComplemented(c1 double, c2 double, c3 double) return double as language java name "oracle.cep.colt.functions.CEPGammaComplemented"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 float, c2 float) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lt(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lt(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="rint(double)">
     <implClass>oracle.cep.colt.functions.CEPRint</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPRint</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function rint(c1 double) return double as language java name "oracle.cep.colt.functions.CEPRint"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="sinh(double)">
     <implClass>oracle.cep.colt.functions.CEPSinh</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPSinh</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sinh(c1 double) return double as language java name "oracle.cep.colt.functions.CEPSinh"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(interval,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 interval, n int, c3 int, c4 timestamp) return interval as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="substr(char,int,int)">
     <implClass>oracle.cep.extensibility.functions.builtin.SubStr</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.SubStr</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function substr(c1 char, c2 int, c3 int) return char as language java name "oracle.cep.extensibility.functions.builtin.SubStr"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="length(byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>b</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function length(b byte) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="divide(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 double, c2 double) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="i1e(double)">
     <implClass>oracle.cep.colt.functions.CEPI1e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI1e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i1e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI1e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="is_null(bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function is_null(c1 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(timestamp,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 timestamp, c2 interval) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="lpad(char,int,char)">
     <implClass>oracle.cep.extensibility.functions.builtin.Lpad</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Lpad</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function lpad(c1 char, c2 int, c3 char) return char as language java name "oracle.cep.extensibility.functions.builtin.Lpad"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="atan2(double,double)">
     <implClass>oracle.cep.colt.functions.CEPAtan2</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPAtan2</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function atan2(c1 double, c2 double) return double as language java name "oracle.cep.colt.functions.CEPAtan2"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="subtract(int,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function subtract(c1 int, c2 int) return int as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="net(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function net(c1 byte, c2 byte) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(double,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 double, n int, c3 int, c4 timestamp) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(timestamp,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 timestamp, c2 timestamp) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(timestamp,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 timestamp, n int) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="i0e(double)">
     <implClass>oracle.cep.colt.functions.CEPI0e</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPI0e</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function i0e(c1 double) return double as language java name "oracle.cep.colt.functions.CEPI0e"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="logFactorial(int)">
     <implClass>oracle.cep.colt.functions.CEPLogFactorial</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.functions.CEPLogFactorial</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function logFactorial(c1 integer) return double as language java name "oracle.cep.colt.functions.CEPLogFactorial"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="et(interval,interval)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function et(c1 interval, c2 interval) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(char,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 char, n int) return char as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="ulp1(float)">
     <implClass>oracle.cep.colt.functions.CEPUlp1</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.colt.functions.CEPUlp1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function ulp1(c1 float) return float as language java name "oracle.cep.colt.functions.CEPUlp1"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="divide(float,float)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function divide(c1 float, c2 float) return float as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="to_double(int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function to_double(c1 int) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gtet(bigint,bigint)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gtet(c1 bigint, c2 bigint) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(double,int)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 double, n int) return double as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="gt(double,double)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function gt(c1 double, c2 double) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="log_and(boolean,boolean)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>boolean</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>boolean</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function log_and(c1 boolean, c2 boolean) return boolean as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="prev(timestamp,int,int,timestamp)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>3</position>
       <name>c4</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function prev(c1 timestamp, n int, c3 int, c4 timestamp) return timestamp as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
    <SimpleFunction Key="nvl(byte,byte)">
     <implClass>null</implClass>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function nvl(c1 byte, c2 byte) return byte as language java name "$dummy"</creationTxt>
     <typ>SINGLE_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunction>
   </SingleFunctions>
   <SimpleFunctions >
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>385</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>431</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>253</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>411</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>219</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>255</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>23</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>263</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>281</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>313</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>128</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>41</funcsElem>
      <funcsElem>43</funcsElem>
      <funcsElem>44</funcsElem>
      <funcsElem>45</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>351</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>403</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>285</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>423</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>5</funcsElem>
      <funcsElem>7</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>339</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>108</funcsElem>
      <funcsElem>110</funcsElem>
      <funcsElem>111</funcsElem>
      <funcsElem>112</funcsElem>
      <funcsElem>113</funcsElem>
      <funcsElem>114</funcsElem>
      <funcsElem>115</funcsElem>
      <funcsElem>116</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>345</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>299</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>10</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>283</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>399</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>249</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>130</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>409</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>217</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>259</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>251</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>261</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>279</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>257</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>363</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>311</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>25</funcsElem>
      <funcsElem>27</funcsElem>
      <funcsElem>28</funcsElem>
      <funcsElem>29</funcsElem>
      <funcsElem>30</funcsElem>
      <funcsElem>31</funcsElem>
      <funcsElem>32</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>297</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>134</funcsElem>
      <funcsElem>136</funcsElem>
      <funcsElem>137</funcsElem>
      <funcsElem>138</funcsElem>
      <funcsElem>139</funcsElem>
      <funcsElem>140</funcsElem>
      <funcsElem>141</funcsElem>
      <funcsElem>142</funcsElem>
      <funcsElem>143</funcsElem>
      <funcsElem>144</funcsElem>
      <funcsElem>145</funcsElem>
      <funcsElem>146</funcsElem>
      <funcsElem>147</funcsElem>
      <funcsElem>148</funcsElem>
      <funcsElem>149</funcsElem>
      <funcsElem>150</funcsElem>
      <funcsElem>151</funcsElem>
      <funcsElem>152</funcsElem>
      <funcsElem>153</funcsElem>
      <funcsElem>154</funcsElem>
      <funcsElem>155</funcsElem>
      <funcsElem>156</funcsElem>
      <funcsElem>157</funcsElem>
      <funcsElem>158</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>122</funcsElem>
      <funcsElem>124</funcsElem>
      <funcsElem>125</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>365</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>353</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>393</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>397</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>307</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>221</funcsElem>
      <funcsElem>223</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>287</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>232</funcsElem>
      <funcsElem>234</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>383</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>12</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>117</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>377</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>213</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>379</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>289</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>99</funcsElem>
      <funcsElem>101</funcsElem>
      <funcsElem>102</funcsElem>
      <funcsElem>103</funcsElem>
      <funcsElem>104</funcsElem>
      <funcsElem>105</funcsElem>
      <funcsElem>106</funcsElem>
      <funcsElem>107</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>381</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>331</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>335</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>329</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>245</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>413</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>341</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>395</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>407</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>51</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>3</funcsElem>
      <funcsElem>9</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>375</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>1</funcsElem>
      <funcsElem>8</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>333</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>132</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>415</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>14</funcsElem>
      <funcsElem>16</funcsElem>
      <funcsElem>17</funcsElem>
      <funcsElem>18</funcsElem>
      <funcsElem>19</funcsElem>
      <funcsElem>20</funcsElem>
      <funcsElem>21</funcsElem>
      <funcsElem>22</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>425</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>235</funcsElem>
      <funcsElem>237</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>355</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>53</funcsElem>
      <funcsElem>55</funcsElem>
      <funcsElem>56</funcsElem>
      <funcsElem>57</funcsElem>
      <funcsElem>58</funcsElem>
      <funcsElem>59</funcsElem>
      <funcsElem>60</funcsElem>
      <funcsElem>61</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>417</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>301</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>419</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>62</funcsElem>
      <funcsElem>64</funcsElem>
      <funcsElem>65</funcsElem>
      <funcsElem>66</funcsElem>
      <funcsElem>67</funcsElem>
      <funcsElem>68</funcsElem>
      <funcsElem>69</funcsElem>
      <funcsElem>70</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>321</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>89</funcsElem>
      <funcsElem>91</funcsElem>
      <funcsElem>92</funcsElem>
      <funcsElem>93</funcsElem>
      <funcsElem>94</funcsElem>
      <funcsElem>95</funcsElem>
      <funcsElem>96</funcsElem>
      <funcsElem>97</funcsElem>
      <funcsElem>98</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>347</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>305</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>315</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>343</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>229</funcsElem>
      <funcsElem>231</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>391</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>309</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>401</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>389</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>427</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>371</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>349</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>323</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>224</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>269</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>265</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>327</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>291</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>46</funcsElem>
      <funcsElem>48</funcsElem>
      <funcsElem>49</funcsElem>
      <funcsElem>50</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>271</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>293</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>126</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>337</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>33</funcsElem>
      <funcsElem>35</funcsElem>
      <funcsElem>36</funcsElem>
      <funcsElem>37</funcsElem>
      <funcsElem>38</funcsElem>
      <funcsElem>39</funcsElem>
      <funcsElem>40</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>215</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>369</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>429</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>367</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>238</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>247</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>405</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>319</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>273</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>303</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>421</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>71</funcsElem>
      <funcsElem>73</funcsElem>
      <funcsElem>74</funcsElem>
      <funcsElem>75</funcsElem>
      <funcsElem>76</funcsElem>
      <funcsElem>77</funcsElem>
      <funcsElem>78</funcsElem>
      <funcsElem>79</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>119</funcsElem>
      <funcsElem>121</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>267</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>275</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>357</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>295</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>80</funcsElem>
      <funcsElem>82</funcsElem>
      <funcsElem>83</funcsElem>
      <funcsElem>84</funcsElem>
      <funcsElem>85</funcsElem>
      <funcsElem>86</funcsElem>
      <funcsElem>87</funcsElem>
      <funcsElem>88</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>277</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>359</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>226</funcsElem>
      <funcsElem>228</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>373</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>361</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>240</funcsElem>
      <funcsElem>242</funcsElem>
      <funcsElem>243</funcsElem>
      <funcsElem>244</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>325</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>317</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
    <SimpleFunctionSet>
     <funcs >
      <funcsElem>387</funcsElem>
     </funcs>
     <typ>SIMPLE_FUNCTION_SET</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </SimpleFunctionSet>
   </SimpleFunctions>
   <AggrFunctions >
    <AggFunction Key="trimmedMean(double,int,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPTrimmedMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  trimmedMean(c1 double, c2 int, c3 int) return double  aggregate using "oracle.cep.colt.aggr.CEPTrimmedMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="SUM(float)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 float) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="autoCorrelation(double,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPAutoCorrelation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  autoCorrelation(c1 double, c2 int) return double  aggregate using "oracle.cep.colt.aggr.CEPAutoCorrelation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(byte)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 byte) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="AVG(bigint)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 bigint) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(char)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 char) return char aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(bigint)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 bigint) return bigint aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 double) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(timestamp)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 timestamp) return timestamp aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(char)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 char) return char aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sumOfSquares(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfSquares</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfSquares(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfSquares" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sampleStandardDeviation(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleStandardDeviation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleStandardDeviation(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleStandardDeviation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(timestamp)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 timestamp) return timestamp aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sumOfInversions(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfInversions</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfInversions(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfInversions" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(float)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 float) return float aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sumOfSquaredDeviations(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfSquaredDeviations</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfSquaredDeviations(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfSquaredDeviations" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(interval)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 interval) return interval aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sumOfPowerDeviations(double,int,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfPowerDeviations</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfPowerDeviations(c1 double, c2 int, c3 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfPowerDeviations" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(char)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 char) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="kurtosis(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPKurtosis</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  kurtosis(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPKurtosis" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sumOfPowers(double,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfPowers</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfPowers(c1 double, c2 int) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfPowers" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(byte,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 byte, n int) return byte aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(interval)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 interval) return interval aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(int,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 int, n int) return int aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="moment(double,int,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMoment</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  moment(c1 double, c2 int, c3 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMoment" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 int) return int aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(float)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
      <destQueriesElem>494</destQueriesElem>
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 float) return float aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(float)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 float) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="variance(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPVariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  variance(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPVariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="lag1(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPLag1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  lag1(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPLag1" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="median(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMedian</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  median(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMedian" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(char,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 char, n int) return char aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="SUM(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 double) return double aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(interval)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 interval) return interval aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="meanDeviation(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMeanDeviation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  meanDeviation(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMeanDeviation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(bigint)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 bigint) return bigint aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(interval,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 interval, n int) return interval aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="correlation(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPCorrelation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  correlation(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPCorrelation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="AVG(float)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 float) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sampleKurtosisStandardError(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleKurtosisStandardError</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleKurtosisStandardError(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleKurtosisStandardError" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sampleSkew(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleSkew</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleSkew(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleSkew" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sampleSkewStandardError(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleSkewStandardError</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleSkewStandardError(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleSkewStandardError" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(bigint,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 bigint, n int) return bigint aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(float,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 float, n int) return float aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="weightedMean(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPWeightedMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  weightedMean(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPWeightedMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(bigint)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 bigint) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="rms(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPRms</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  rms(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPRms" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(int,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 int, n int) return int aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(float)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 float) return float aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="pooledMean(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPPooledMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  pooledMean(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPPooledMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="standardError(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPStandardError</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  standardError(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPStandardError" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="winsorizedMean(double,int,int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>int</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>2</position>
       <name>c3</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPWinsorizedMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  winsorizedMean(c1 double, c2 int, c3 int) return double  aggregate using "oracle.cep.colt.aggr.CEPWinsorizedMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(timestamp)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 timestamp) return timestamp aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 int) return int aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(double,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 double, n int) return double aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="geometricMean(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPGeometricMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  geometricMean(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPGeometricMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(timestamp,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 timestamp, n int) return timestamp aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(float,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>float</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 float, n int) return float aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="SUM(int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 int) return int aggregate using "$dummy" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="product(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPProduct</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  product(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPProduct" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 int) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="rankInterpolated(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPRankInterpolated</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  rankInterpolated(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPRankInterpolated" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="skew(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSkew</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  skew(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSkew" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="AVG(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 double) return double aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="pooledVariance(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPPooledVariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  pooledVariance(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPPooledVariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(double)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 double) return double aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="geometricMean1(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPGeometricMean1</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  geometricMean1(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPGeometricMean1" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="durbinWatson(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPDurbinWatson</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  durbinWatson(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPDurbinWatson" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(byte)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 byte) return byte aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(timestamp)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 timestamp) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(byte)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 byte) return byte aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="SUM(bigint)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function sum(c1 bigint) return bigint aggregate using "$dummy" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="standardDeviation(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPStandardDeviation</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  standardDeviation(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPStandardDeviation" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(char,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 char, n int) return char aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(byte,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 byte, n int) return byte aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="AVG(int)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>float</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function avg(c1 int) return float aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MAX(byte)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>byte</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>byte</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function max(c1 byte) return byte aggregate using"$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="COUNT(interval)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>int</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function count(c1 interval) return int aggregate using "$dummy"  supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sampleKurtosis(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleKurtosis</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleKurtosis(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleKurtosis" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(bigint,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>bigint</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>bigint</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 bigint, n int) return bigint aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="quantile(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPQuantile</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  quantile(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPQuantile" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(timestamp,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>timestamp</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>timestamp</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 timestamp, n int) return timestamp aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sumOfLogarithms(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSumOfLogarithms</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sumOfLogarithms(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSumOfLogarithms" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="tklog_secondMax(char)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>char</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>char</returnType>
     <implClassName>oracle.cep.test.userfunctions.TkUsrSecondMax</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt> create function tklog_secondMax(c1 char) return char aggregate using "oracle.cep.test.userfunctions.TkUsrSecondMax" </creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="covariance(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPCovariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  covariance(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPCovariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="mean(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  mean(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="harmonicMean(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPHarmonicMean</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  harmonicMean(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPHarmonicMean" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="quantileInverse(double,double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>c2</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPQuantileInverse</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  quantileInverse(c1 double, c2 double) return double  aggregate using "oracle.cep.colt.aggr.CEPQuantileInverse" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="sampleVariance(double)">
     <supportsIncremental>true</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.colt.aggr.CEPSampleVariance</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function  sampleVariance(c1 double) return double  aggregate using "oracle.cep.colt.aggr.CEPSampleVariance" supports incremental computation</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="MIN(double)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>$dummy</implClassName>
     <builtIn>true</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function min(c1 double) return double aggregate using "$dummy"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="LAST(double,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>double</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>double</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.Last</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function last(c1 double, n int) return double aggregate using "oracle.cep.extensibility.functions.builtin.Last"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
    <AggFunction Key="FIRST(interval,int)">
     <supportsIncremental>false</supportsIncremental>
     <factory>null</factory>
     <paramList >
      <Attribute>
       <position>0</position>
       <name>c1</name>
       <type>interval</type>
       /maxLength>
      </Attribute>
      <Attribute>
       <position>1</position>
       <name>n</name>
       <type>int</type>
       /maxLength>
      </Attribute>
     </paramList>
     <returnType>interval</returnType>
     <implClassName>oracle.cep.extensibility.functions.builtin.First</implClassName>
     <builtIn>false</builtIn>
     <destQueries >
     </destQueries>
     <creationTxt>create function first(c1 interval, n int) return interval aggregate using "oracle.cep.extensibility.functions.builtin.First"</creationTxt>
     <typ>AGGR_FUNCTION</typ>
     <nameSpace>USERFUNCTION</nameSpace>
     <bDirty>false</bDirty>
     <bLoaded>true</bLoaded>
     <change>NONE</change>
     <lock>java.util.concurrent.locks.ReentrantReadWriteLock[Write locks = 0, Read locks = 0]</lock>
     <refCount>0</refCount>
    </AggFunction>
   </AggrFunctions>
  </Level>
 </Event>

 oracle.cep.logging.LogUtil log
INFO: Activate : DDL success
